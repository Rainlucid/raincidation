using System.Numerics;
using Content.Shared._RD.Perks.Components;
using Content.Shared._RD.Perks.Modules.Restrictions;
using Content.Shared._RD.Perks.Prototypes;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Prototypes;

namespace Content.Client._RD.Perks.UI;

[GenerateTypedNameReferences]
public sealed partial class RDPerkTreeGraphControl : Control
{
    private const float GridSizeMax = 50f;
    private const float GridSizeMin = 25f;
    private const float LocalUIScaleMax = 4f;
    private const float LocalUIScaleMin = 1f;

    [Dependency] private readonly IEntityManager _entity = default!;
    [Dependency] private readonly IPrototypeManager _prototype = default!;

    public event Action<RDPerkPrototype?>? OnNodeSelected;
    public event Action<Vector2>? OnOffsetChanged;

    public RDPerkTreePrototype? Tree;

    private readonly SpriteSystem _sprite;
    private readonly RDPerkSystem _perk;

    private Entity<RDPerkContainerComponent>? _player;
    private Vector2 _previousMousePosition = Vector2.Zero;
    private Vector2 _globalOffset = new(60,60);
    private float _gridSize = GridSizeMin;
    private float _localUIScale = LocalUIScaleMin;

    private RDPerkPrototype? _hoveredNode;
    private RDPerkPrototype? _selectedNode;

    private bool _dragging;

    private float Scale => UIScale * _localUIScale;

    public RDPerkTreeGraphControl()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _sprite = _entity.System<SpriteSystem>();
        _perk = _entity.System<RDPerkSystem>();
    }

    public void UpdateState(Entity<RDPerkContainerComponent> player)
    {
        _player = player;
        OnOffsetChanged?.Invoke(_globalOffset);
    }

    protected override void MouseWheel(GUIMouseWheelEventArgs args)
    {
        base.MouseWheel(args);

        if (args.Handled)
            return;

        // _gridSize = MathHelper.Clamp(_gridSize + 5 * args.Delta.Y, GridSizeMin, GridSizeMax);
        _localUIScale = MathHelper.Clamp(_localUIScale + 0.1f * args.Delta.Y, LocalUIScaleMin, LocalUIScaleMax);
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (args.Handled)
            return;

        if (args.Function == EngineKeyFunctions.UIClick)
        {
            _dragging = true;

            if (_hoveredNode == null)
                return;

            OnNodeSelected?.Invoke(_hoveredNode);
            UserInterfaceManager.ClickSound();
            _selectedNode = _hoveredNode;
        }

        if (args.Function != EngineKeyFunctions.UIRightClick)
            return;

        // Reset offset on right click
        _gridSize = GridSizeMin;
        _localUIScale = LocalUIScaleMin;
        _globalOffset = new Vector2(60, 60);
        OnOffsetChanged?.Invoke(_globalOffset);
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        if (args.Handled || args.Function != EngineKeyFunctions.UIClick)
            return;

        _dragging = false;
    }

    protected override void ExitedTree()
    {
        base.ExitedTree();

        OnNodeSelected?.Invoke(null);
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        _hoveredNode = null;
        if (_player is null || Tree is null)
            return;

        var cursor = UserInterfaceManager.MousePositionScaled.Position * UIScale - GlobalPixelPosition;
        if (_dragging)
        {
            var delta = cursor - _previousMousePosition;

            _globalOffset += delta * (1 / _localUIScale);
            OnOffsetChanged?.Invoke(_globalOffset);
        }

        _previousMousePosition = cursor;

        // Draw connection lines
        foreach (var perk in _perk.PerkPrototypes)
        {
            if (perk.Tree != Tree)
                continue;

            var fromPosition = perk.UIPosition * _gridSize * Scale + _globalOffset;
            foreach (var restriction in perk.Restrictions)
            {
                if (restriction is not Precondition precondition)
                    continue;

                foreach (var preconditionPerk in precondition.Perks)
                {
                    if (!_prototype.TryIndex(preconditionPerk, out var preconditionPerkPrototype))
                        continue;

                    if (preconditionPerkPrototype.Tree != Tree)
                        continue;

                    var learned = _perk.Learned((_player.Value, _player), preconditionPerk);
                    var targetPosition = preconditionPerkPrototype.UIPosition * _gridSize * Scale + _globalOffset;
                    var color = learned ? Color.Green : Color.FromHex("#b3b3b3");

                    handle.DrawLine(fromPosition, targetPosition, color);
                }
            }
        }

        // Draw skill icons over lines
        foreach (var perk in _perk.PerkPrototypes)
        {
            if (perk.Tree != Tree)
                continue;

            // TODO: Not optimized, recalculates every frame. Needs to be calculated on state update and cached.
            var canBeLearned = _perk.CanLearn((_player.Value, _player), perk);
            var position = perk.UIPosition * _gridSize * Scale + _globalOffset;

            // Base skill icon
            var baseTexture = _sprite.Frame0(perk.Icon);
            var baseSize = new Vector2(baseTexture.Width, baseTexture.Height) * 1.5f * Scale;
            var baseQuad = new UIBox2(position - baseSize / 2, position + baseSize / 2);
            var hovered = (cursor - position).LengthSquared() <= (baseSize.X / 2) * (baseSize.X / 2);

            // Frame
            var frameTexture = _sprite.Frame0(Tree.FrameIcon);
            var frameSize = new Vector2(frameTexture.Width, frameTexture.Height) * 1.5f * Scale;
            var frameQuad = new UIBox2(position - frameSize / 2, position + frameSize / 2);
            handle.DrawTextureRect(frameTexture, frameQuad, canBeLearned ? Color.White : Color.FromHex("#b3b3b3"));

            // Selected Skill
            if (_selectedNode == perk)
            {
                var selectedTexture = _sprite.Frame0(Tree.SelectedIcon);
                var selectedSize = new Vector2(selectedTexture.Width, selectedTexture.Height) * 1.5f * Scale;
                var selectedQuad = new UIBox2(position - selectedSize / 2, position + selectedSize / 2);
                handle.DrawTextureRect(selectedTexture, selectedQuad, Color.White);
            }

            // Hovered Skill
            if (hovered)
            {
                _hoveredNode = perk;
                var hoveredTexture = _sprite.Frame0(Tree.HoveredIcon);
                var hoveredSize = new Vector2(hoveredTexture.Width, hoveredTexture.Height) * 1.5f * Scale;
                var hoveredQuad = new UIBox2(position - hoveredSize / 2, position + hoveredSize / 2);
                handle.DrawTextureRect(hoveredTexture, hoveredQuad, Color.White);
            }

            var learned = _perk.Learned((_player.Value, _player), perk);
            var allowedToLearn = _perk.AllowLearn((_player.Value, _player), perk);

            // Learned Skill
            if (learned)
            {
                var learnedTexture = _sprite.Frame0(Tree.LearnedIcon);
                var learnedSize = new Vector2(learnedTexture.Width, learnedTexture.Height) * 1.5f * Scale;
                var learnedQuad = new UIBox2(position - learnedSize / 2, position + learnedSize / 2);
                handle.DrawTextureRect(learnedTexture, learnedQuad, Color.White);
            }
            else if (canBeLearned)
            {
                var availableTexture = _sprite.Frame0(Tree.AvailableIcon);
                var availableSize = new Vector2(availableTexture.Width, availableTexture.Height) * 1.5f * Scale;
                var availableQuad = new UIBox2(position - availableSize / 2, position + availableSize / 2);
                handle.DrawTextureRect(availableTexture, availableQuad, Color.White);
            }

            var iconColor = allowedToLearn switch
            {
                true when !learned => Color.FromHex("#b1b1b1"),
                false when !learned => Color.Black,
                _ => Color.White,
            };

            handle.DrawTextureRect(baseTexture, baseQuad, iconColor);
        }
    }
}
